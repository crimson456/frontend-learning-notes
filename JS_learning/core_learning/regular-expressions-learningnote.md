# Regular Expressions Learning

可视化正则工具：https://regexper.com/

## 创建正则表达式

```js
//字面量（无需进行字符串转义）
let reg=/pattern/flags


//构造函数
let reg=new RegExp(pattern,flags)
```
>！！！注意：使用构造函数创建正则表达式时
>pattern为一个字符串，在字符串中写入某些字符如`/`需要满足字符串中的转义，所以实际有些需要转义的正则需要转义两次
>实际使用时可以将pattern作为字符串打印在控制台检查是否出错


## 常用正则规则pattern


1. 字符类
    1. `.`匹配除了换行符外任意字符
    2. `\s`匹配空白字符，如空格，回车，制表符
    3. `\S`匹配除了空白字符的任意字符
    4. `\d`匹配数字0-9，等价于`[0-9]`
    5. `\D`匹配除了数字0-9
    6. `\w`匹配所有字母数字和下划线，等价于`[a-zA-z0-9_]`
    7. `\W`匹配除了所有字母数字和下划线
   
    8. `\t`匹配水平制表符
    9.  `\r`匹配回车符
    10. `\n`匹配换行符
    11. `\v`匹配垂直制表符
    12. `\f`匹配换页符
    13. `[\b]`匹配退格键
   

    14. `\0`匹配一个 NUL 字符。不要在此后面加上另一个数字
    15. `\cX`使用插入符号匹配控制字符，其中“X”是 A–Z 中的一个字母
    16. `\xhh`匹配与代码h（两个十六进制数字对应的字符
    17. `\uhhhh`匹配与值hhhh（四个十六进制数字）对应的 UTF-16 代码单元
    18. `\u{hhhh}`或`\u{hhhhh}`（仅当设置了u标志时）匹配与Unicode值U+hhhh或U+hhhhh（十六进制数字）对应的字符
    19. `\p{UnicodeProperty}`、`\P{UnicodeProperty}`配合匹配模式`u`使用，详细查文档？
    ???不常用，详细查文档


2. 断言类
    1.  `^`起始边界
    2.  `$`结束边界
    3.  `x(?=y)`匹配后面有y的x
    4.  `x(?!y)`匹配后面没有y的x
    5.  `(?<=y)x`匹配前面有y的x
    6.  `(?<!y)x`匹配前面没有y的x
    7.  `\b`匹配单词边界,可理解为后面或前面没有单词跟随
    8.  `\B`匹配非单词边界，可理解为后面或前面有单词跟随
        >例子：`/\bxyz/`可以匹配xyza中的xyz，但不能匹配axyz中的xyz，`/\Bxyz/`可以匹配axyz中的xyz，但不能匹配xyza中的xyz

3. 分组类
    1. `[]`字符集(原子表)，任选其中一个字符，可以用`-`升序连接,`-`也可以代表中
        >类似`(a|b|c|d|e)`
        >`[a-z]`表示任意字母
        >`[]`中的有些符号就只表示原符号，如`(`和`)`就表示括号，`.`表示点号
    2. `[^]`匹配除了其中字符以外的字符 
   
    3. `()`捕获组(原子组)，根据左括号的顺序排序，匹配的结果会放在结果数组对象中的`1-99`属性下，且可以在此正则表达中用`\1`-`\99`重用
    4. `(:?)`不捕获组
    5. `(?<名称>)`具名捕获组(原子组)，匹配的结果会放在结果数组对象中的group属性下
        ？不捕获组和具名捕获组是否可以通过`\1`-`\99`重用，预估：可

    6. `x|y`或者
        >注意会匹配到括号内所有内容，如`abc|def`匹配的是abc或def，而不是abcef或abdef




4.  量词类：   
    1. `{min,max}`、`{num}`限制个数
    2.  `+`前面的字符匹配1个或多个
    3.  `*`前面的字符匹配0个或多个
    4.  `?`前面的字符匹配0个或1个
        >`{min,max}?`、`+?`、`*?`、`??`中的后一个`?`表示禁止贪婪，即匹配尽量少的字符，默认为匹配尽量多的字符




5.  `\`表示转义，转义的字符：（元字符）
   1. `\.`只匹配`.`号
   2. `\/`只匹配`/`号
   3. `\s`匹配空白字符，如空格，回车，制表符
   4. `\S`匹配除了空白字符的任意字符
   5. `\d`匹配数字0-9，等价于`[0-9]`
   6. `\D`匹配除了数字0-9
   7. `\w`匹配所有字母数字和下划线，等价于`[a-zA-z0-9_]`
   8. `\W`匹配除了所有字母数字和下划线
   9. `\b`匹配单词的边界
   10. `\B`匹配非单词边界
   11. `\1`-`\99`原子组


   12. `\t`匹配水平制表符
   13. `\r`匹配回车符
   14. `\n`匹配换行符
   15. `\v`匹配垂直制表符
   16. `\f`匹配换页符
   17. `[\b]`匹配退格键

   18. `\0`匹配一个 NUL 字符。不要在此后面加上另一个数字
   19. `\cX`使用插入符号匹配控制字符，其中“X”是 A–Z 中的一个字母
   20. `\xhh`匹配与代码h（两个十六进制数字对应的字符
   21. `\uhhhh`匹配与值hhhh（四个十六进制数字）对应的 UTF-16 代码单元
   22. `\u{hhhh}`或`\u{hhhhh}`（仅当设置了u标志时）匹配与Unicode值U+hhhh或U+hhhhh（十六进制数字）对应的字符
   23. `\p{UnicodeProperty}`、`\P{UnicodeProperty}`配合匹配模式`u`使用，详细查文档？
    ???不常用，详细查文档




巧妙用法：
1. `[\s\S]`或`[\d\D]`或`[\w\W]`表示匹配所有字符
2. 匹配标签:
    ```js
    var reg=/<h1>[/d/D]+?<\/h1>/gi
    ```

## flags 匹配模式

1. `s`视为单行进行匹配，并允许`.`匹配换行符
2. `i`不区分大小写
3. `g`全局模式，全局匹配(默认只匹配一个)，贪婪，从`lastIndex`的位置作为起始搜索位置进行匹配，如匹配成功，则更新`lastIndex`，如失败，则将`lastIndex`置0
4. `m`作为多行进行匹配，每行单独处理
5. `u`使用unicode码的模式进行匹配，可配合`\p{}`和`\P{}`使用，可用于匹配外文，特殊符号，详细查文档
6. `y`粘性模式，从`lastIndex`的位置作为起始限定位置直接进行匹配（不需要边界符限定），如匹配成功，则更新`lastIndex`，如失败，则将`lastIndex`置0

>`g`和`y`模式区别：
>`g`模式会在匹配到一个匹配项后继续进行匹配，后续的匹配项和前项之间可以间隔任意字符
>`y`模式只会在匹配到一个匹配项后，后续的匹配项与前一项无间隔的时候才会匹配成功


## RegExp 对象

1. 属性
   1. `RegExp.prototype.lastIndex`全局模式和粘性模式下上一次搜索的记录
        >在全局模式下调用相关方法如exec时直接在控制台打印RegExp对象此参数会一直为常数（最终值），猜测与getter有关？？？,但打印对象下的此属性则正常
   2. `RegExp.prototype.source`正则对象的匹配规则的字符串pattern
   3. `RegExp.prototype.flags`正则对象的匹配模式flags
   4. `RegExp.prototype.global`全局模式g
   5. `RegExp.prototype.ignoreCase`不区分大小写i
   6. `RegExp.prototype.dotAll`单行匹配，并允许`.`匹配换行符s
   7. `RegExp.prototype.multiline`多行匹配m
   8. `RegExp.prototype.unicode`使用unicode码的模式进行匹配u
   9. `RegExp.prototype.sticky`粘性模式y



2. 原型对象上的方法


    1. `RegExp.prototype.test(str)`
        验证字符串是否满足正则表达式，返回布尔值，如果为`g`全局模式则从`lastIndex`记录的位置开始匹配，并在匹配到后记录新的`lastIndex`

    2. `RegExp.prototype.exec(str)`
        验证字符串是否满足正则表达式，返回满足正则表达式的一项的详细信息组成的数组（捕获组）,如果为`g`全局模式则从`lastIndex`记录的位置开始匹配，并在匹配到后记录新的`lastIndex`



## String 对象下的相关方法

1. `replace(regexp|substr, newSubStr|function)`
    替换对应第一个字符串或正则表达式匹配项为新的字符串或用函数修改，返回新的字符串
    第一个参数为普通字符串或正则表达式，表示要替换的内容
    第二个参数为一个字符串或函数，决定替换后的内容

    >第二个参数如使用模板字符串，可用`$`转义
    >1. `$0`代表原字符串
    >2. `$1`-`$99`代表正则中原子组，顺序为左括号出现的顺序
    >3. `$&`代表匹配的子串
    >4. `$$`代表`$`字符
    >5. `$`\`($加反引号）代表插入当前匹配的子串左边的内容
    >6. `$'`（$加单引号）代表插入当前匹配的子串右边的内容
    >7. `$<Name>`代表命名分组

    >第二个参数如使用函数replacer(match, ...pn, offset, string，NamedCaptureGroup)
    >1. match代表匹配的子串
    >2. pn代表第n个原子组
    >3. offset代表匹配到的子字符串在原字符串中的偏移量
    >4. string代表原字符串
    >5. NamedCaptureGroup代表命名捕获组匹配的对象

2. `replaceAll(regexp|substr, newSubstr|function)`
    替换对应字符串或正则表达式匹配项为新的字符串或用函数修改，返回新的字符串

3. `match(regexp)`
    返回当前字符串匹配正则表达式的结果
    >如果正则为全局模式g，则返回所有匹配项组成的数组，但无捕获组等其他信息（粗略）
    >如果正则不为全局模式g，则只返回第一个匹配项的完整信息数组，包括捕获组（详细）

4. `matchAll(regexp)`
    返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器

5. `split(separator, limit)`
    根据分隔符（字符串或正则表达式）将字符串分割成字符串片段，并返回对应限制数量片段的数组

6. `search(regexp)`
    返回正则表达式在字符串中首次匹配项的索引